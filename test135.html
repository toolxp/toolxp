<style>
	#resultContainer td {
color: #ddd;
	}
	body {
background: #000;		
	}
  /* å‘¼å¸ç¯æ•ˆæœçš„é˜´å½±åŠ¨ç”» */
  @keyframes breathing {
    0% {
      box-shadow: 0 0 20px rgba(52, 152, 219, 0.7); /* åˆå§‹é˜´å½± */
    }
    50% {
      box-shadow: 0 0 40px rgba(52, 152, 219, 0.2); /* æœ€å¤§é˜´å½± */
    }
    100% {
      box-shadow: 0 0 20px rgba(52, 152, 219, 0.7); /* è¿”å›åˆå§‹é˜´å½± */
    }
  }
</style>
<style>
.engine-loader {
  position: relative;
  width: 76px;
  height: 76px;
  perspective: 510px;
  margin: 70px auto;
}
.inner {
  position: absolute;
  box-sizing: border-box;
  width: 100%;
  height: 100%;
  border-radius: 50%;
}
.inner.one {
  left: 0;
  top: 0;
  border-bottom: 3px solid #efeffa;
  animation: rotate-one 1s linear infinite;
  transform: rotateX(35deg) rotateY(-45deg);
}
.inner.two {
  right: 0;
  top: 0;
  border-right: 3px solid #efeffa;
  animation: rotate-two 1s linear infinite;
  transform: rotateX(50deg) rotateY(10deg);
}
.inner.three {
  right: 0;
  bottom: 0;
  border-top: 3px solid #efeffa;
  animation: rotate-three 1s linear infinite;
  transform: rotateX(35deg) rotateY(55deg) rotateZ(360deg);
}

@keyframes rotate-one {
  0% { transform: rotateX(35deg) rotateY(-45deg) rotateZ(0deg); }
  100% { transform: rotateX(35deg) rotateY(-45deg) rotateZ(360deg); }
}
@keyframes rotate-two {
  0% { transform: rotateX(50deg) rotateY(10deg) rotateZ(0deg); }
  100% { transform: rotateX(50deg) rotateY(10deg) rotateZ(360deg); }
}
@keyframes rotate-three {
  0% { transform: rotateX(35deg) rotateY(55deg) rotateZ(0deg); }
  100% { transform: rotateX(35deg) rotateY(55deg) rotateZ(360deg); }
}
</style>


<style>
#output {
  white-space: pre-wrap;
  font-family: monospace;
  text-align: center;
  font-size: 21px;
  opacity: 1;
  transition: opacity 0.3s ease-in-out;
  color:#fff;
}

span#finalResult {
    line-height: 2.6;
}

@keyframes fadeInOut {
  0% { opacity: 0.2; }
  50% { opacity: 1; }
  100% { opacity: 0.6; }
}

@media screen and (max-width: 600px) {
  #detectBtn {
    width: 80%;
    font-size: 14px;
  }
  #output {
    font-size: 14px;
  }
}
@keyframes blink-animation {
  0% { opacity: 0.2; }
  50% { opacity: 1; }
  100% { opacity: 0.2; }
}

.flashStep {
  animation: blink-animation 1.5s infinite ease-in-out;
}

#detectBtn {
    display: block;
    margin: 90px auto 70px auto;
    background: #8d28a5;
    color: #fff;
    border: none;
    width: 200px;
    height: 50px;
    font-size: 17px;
}

#detectBtn:hover {
    background: #2e93ff;
    color: #fff;
}
</style>


<!--<button id="detectBtn" onclick="runAnalysis()" aria-label="ç‚¹å‡»æŒ‰é’®å¼€å§‹æ£€æµ‹">å¼€å§‹æ£€æµ‹</button>-->
		<button id="detectBtn" aria-label="ç‚¹å‡»æŒ‰é’®å¼€å§‹æ£€æµ‹">å¼€å§‹æ£€æµ‹</button>


  <div id="engine-loader" class="engine-loader" style="display: none;">
    <div class="inner one"></div>
    <div class="inner two"></div>
    <div class="inner three"></div>
  </div>

  <div id="resultContainer">
<pre id="output">
  <span id="statusText"></span> <!-- åŠ ä¸Šè¿™ä¸ªï¼æç¤ºæ–‡å­—ä¸“ç”¨ -->
  <br>
  <span id="finalResult"></span> <!-- æœ€ç»ˆæ£€æµ‹ç»“æœ -->
</pre>

</div>


<script>
// ç¬¬ä¸€æ®µJS
window.addEventListener("DOMContentLoaded", () => {
  const statusText = document.getElementById("statusText");
  const finalResult = document.getElementById("finalResult");
  const detectBtn = document.getElementById("detectBtn");
  const resultContainer = document.getElementById("resultContainer");

  const loader = document.getElementById("engine-loader") || (() => {
    const el = document.createElement("div");
    el.id = "engine-loader";
    el.style.display = "none";
    el.style.position = "fixed";
    el.style.top = "50%";
    el.style.left = "50%";
    el.style.transform = "translate(-50%, -50%)";
    el.style.padding = "20px";
    el.style.background = "#00000080";
    el.style.color = "#fff";
    el.style.fontSize = "18px";
    el.style.borderRadius = "12px";
    el.style.zIndex = "9999";
    el.innerText = "æ­£åœ¨æ£€æµ‹ä¸­â€¦";
    document.body.appendChild(el);
    return el;
  })();

  const CONFIG = {
    pingURL: "https://us.cti.pp.ua/ping",
    wsURL: "wss://us.cti.pp.ua/ws",
    tcpipAPI: "https://tcp.cti.pp.ua/classify",
    wsTimeout: 8000,
    webrtcTimeout: 8000,
    stunServers: [
      { urls: "stun:stun.ss.aaak.dpdns.org:3478" },
      { urls: "stun:stun.cc.aaak.dpdns.org:3478" },
      { urls: "stun:stun1.l.google.com:19302" }
    ],
    vpsRegion: "US"
  };

const GEO_BASELINE = {
  "AE": { "US": { expectedRTT: 239, tolerance: 100 } }, // é˜¿è”é…‹
  "AT": { "US": { expectedRTT: 161, tolerance: 100 } }, // å¥¥åœ°åˆ©
  "AU": { "US": { expectedRTT: 221, tolerance: 100 } }, // æ¾³å¤§åˆ©äºš
  "BD": { "US": { expectedRTT: 232, tolerance: 100 } }, // å­ŸåŠ æ‹‰å›½
  "BR": { "US": { expectedRTT: 229, tolerance: 100 } }, // å·´è¥¿
  "CA": { "US": { expectedRTT: 64, tolerance: 60 } }, // åŠ æ‹¿å¤§
  "CH": { "US": { expectedRTT: 159, tolerance: 100 } }, // ç‘å£«
  "CL": { "US": { expectedRTT: 146, tolerance: 60 } }, // æ™ºåˆ©
  "CY": { "US": { expectedRTT: 206, tolerance: 100 } }, // å¡æµ¦è·¯æ–¯
  "DE": { "US": { expectedRTT: 139, tolerance: 60 } }, // å¾·å›½
  "ES": { "US": { expectedRTT: 150, tolerance: 100 } }, // è¥¿ç­ç‰™
  "FR": { "US": { expectedRTT: 133, tolerance: 60 } }, // æ³•å›½
  "GB": { "US": { expectedRTT: 133, tolerance: 60 } }, // è‹±å›½
  "HK": { "US": { expectedRTT: 55, tolerance: 70 } }, // é¦™æ¸¯
  "IL": { "US": { expectedRTT: 200, tolerance: 100 } }, // ä»¥è‰²åˆ—
  "IN": { "US": { expectedRTT: 211, tolerance: 100 } }, // å°åº¦
  "IR": { "US": { expectedRTT: 229, tolerance: 100 } }, // ä¼Šæœ—
  "JP": { "US": { expectedRTT: 107, tolerance: 60 } }, // æ—¥æœ¬
  "KR": { "US": { expectedRTT: 141, tolerance: 60 } }, // éŸ©å›½
  "MA": { "US": { expectedRTT: 161, tolerance: 100 } }, // æ‘©æ´›å“¥
  "NL": { "US": { expectedRTT: 138, tolerance: 60 } }, // è·å…°
  "NO": { "US": { expectedRTT: 151, tolerance: 100 } }, // æŒªå¨
  "RO": { "US": { expectedRTT: 176, tolerance: 100 } }, // ç½—é©¬å°¼äºš
  "SG": { "US": { expectedRTT: 178, tolerance: 100 } }, // æ–°åŠ å¡
  "TH": { "US": { expectedRTT: 201, tolerance: 100 } }, // æ³°å›½
  "TR": { "US": { expectedRTT: 216, tolerance: 100 } }, // åœŸè€³å…¶
  "TW": { "US": { expectedRTT: 136, tolerance: 60 } }, // å°æ¹¾
  "US": { "US": { expectedRTT: 60, tolerance: 60 } }, // ç¾å›½
  "RU": { "US": { expectedRTT: 179, tolerance: 100 } }, // ä¿„ç½—æ–¯
  "UA": { "US": { expectedRTT: 176, tolerance: 100 } }, // ä¹Œå…‹å…°
  "ZA": { "US": { expectedRTT: 273, tolerance: 100 } }, // å—é
  "NZ": { "US": { expectedRTT: 138, tolerance: 100 } }, // æ–°è¥¿å…°
  "GR": { "US": { expectedRTT: 187, tolerance: 100 } }, // å¸Œè…Š
  "FI": { "US": { expectedRTT: 165, tolerance: 100 } }, // èŠ¬å…°
  "PL": { "US": { expectedRTT: 165, tolerance: 100 } }, // æ³¢å…°
  "IT": { "US": { expectedRTT: 152, tolerance: 100 } }, // æ„å¤§åˆ©
  "IE": { "US": { expectedRTT: 149, tolerance: 100 } }, // çˆ±å°”å…°
  "BE": { "US": { expectedRTT: 138, tolerance: 100 } }, // æ¯”åˆ©æ—¶
  "PT": { "US": { expectedRTT: 171, tolerance: 100 } }, // è‘¡è„ç‰™
  "CZ": { "US": { expectedRTT: 170, tolerance: 100 } }, // æ·å…‹
  "LU": { "US": { expectedRTT: 148, tolerance: 100 } }, // å¢æ£®å ¡
  "BG": { "US": { expectedRTT: 167, tolerance: 100 } }, // ä¿åŠ åˆ©äºš
  "MD": { "US": { expectedRTT: 184, tolerance: 100 } }, // æ‘©å°”å¤šç“¦
  "HR": { "US": { expectedRTT: 162, tolerance: 100 } }, // å…‹ç½—åœ°äºš
  "DK": { "US": { expectedRTT: 142, tolerance: 100 } }, // ä¸¹éº¦
  "EE": { "US": { expectedRTT: 154, tolerance: 100 } }, // çˆ±æ²™å°¼äºš
  "KZ": { "US": { expectedRTT: 237, tolerance: 100 } }, // å“ˆè¨å…‹æ–¯å¦
  "AM": { "US": { expectedRTT: 197, tolerance: 100 } }, // äºšç¾å°¼äºš
  "AZ": { "US": { expectedRTT: 221, tolerance: 100 } }, // é˜¿å¡æ‹œç–†
  "NG": { "US": { expectedRTT: 237, tolerance: 100 } }, // å°¼æ—¥åˆ©äºš
  "PE": { "US": { expectedRTT: 137, tolerance: 100 } }, // ç§˜é²
  "CO": { "US": { expectedRTT: 94, tolerance: 100 } },  // å“¥ä¼¦æ¯”äºš
  "AR": { "US": { expectedRTT: 146, tolerance: 100 } }, // é˜¿æ ¹å»·
  "PH": { "US": { expectedRTT: 173, tolerance: 100 } }, // è²å¾‹å®¾ï¼ˆé©¬å°¼æ‹‰ï¼Œç¨³å®šæ— ä¸¢åŒ…ï¼‰
  "EG": { "US": { expectedRTT: 188, tolerance: 100 } }, // åŸƒåŠï¼ˆå¼€ç½—ï¼Œç¨³å®šæ— ä¸¢åŒ…ï¼‰
  "HU": { "US": { expectedRTT: 157, tolerance: 80 } }, // åŒˆç‰™åˆ©
  "LT": { "US": { expectedRTT: 172, tolerance: 80 } }, // ç«‹é™¶å®›
  "RS": { "US": { expectedRTT: 172, tolerance: 80 } }, // å¡å°”ç»´äºš
  "SI": { "US": { expectedRTT: 161, tolerance: 80 } }, // æ–¯æ´›æ–‡å°¼äºš
  "SE": { "US": { expectedRTT: 152, tolerance: 60 } }, // ç‘å…¸
  "VN": { "US": { expectedRTT: 200, tolerance: 100 } }, // è¶Šå—ï¼ˆHo Chi Minh å®æµ‹ 203.9msï¼‰
  "ID": { "US": { expectedRTT: 190, tolerance: 120 } }, // å°åº¦å°¼è¥¿äºšï¼ˆJakarta å®æµ‹ 186.9msï¼‰
  "MY": { "US": { expectedRTT: 180, tolerance: 100 } } // é©¬æ¥è¥¿äºš
};


  const IPStore = {
    webrtc: null,
    ipapi: null,
    ipapiData: null,
    ping: null,
    tcp: null
  };

  function withTimeout(promise, timeoutMs) {
    return Promise.race([
      promise,
      new Promise(resolve => setTimeout(() => resolve(null), timeoutMs))
    ]);
  }

  async function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  function flashUpdate(text) {
    statusText.textContent = text;
    finalResult.textContent = "";
    statusText.classList.remove("flashStep");
    void statusText.offsetWidth;
    statusText.classList.add("flashStep");
  }

  function getBrowserTimezone() {
    try {
      return Intl.DateTimeFormat().resolvedOptions().timeZone || "Unknown";
    } catch {
      return "Unknown";
    }
  }

  function showResultHTML(items, score) {
    const container = document.createElement("div");
    container.style.margin = "auto";
    container.style.borderRadius = "25px";
    container.style.padding = "20px";
    container.style.color = "#ddd";
    container.style.fontSize = "17px";
    container.style.width = "90%";
    container.style.animation = "breathing 3s ease-in-out infinite";
    container.style.transition = "box-shadow 0.3s ease";
    container.style.background = "#00000030";

    const table = document.createElement("table");
    table.style.width = "100%";
    table.style.borderCollapse = "collapse";

    // ç¬¬äºŒæ®µJS
items.forEach(([label, status, color]) => {
  const row = document.createElement("tr");

  const left = document.createElement("td");
  left.textContent = label;
  left.style.padding = "8px";
  left.style.borderBottom = "1px solid #2c3b51";
  left.style.fontWeight = "bold";

  const right = document.createElement("td");
  right.textContent = status;
  right.style.padding = "8px";
  right.style.borderBottom = "1px solid #2c3b51";
  right.style.color = color;
  right.style.fontWeight = "bold";

  row.appendChild(left);
  row.appendChild(right);
  table.appendChild(row);
});

let color = "#00ff22";
if (score > 70) color = "#fb0000";
else if (score > 30) color = "#fff900";

const footer = document.createElement("div");
footer.style.marginTop = "50px";
footer.style.fontSize = "21px";
footer.style.textAlign = "center";
footer.style.fontWeight = "bold";
footer.innerHTML = `ğŸ¯ ä½¿ç”¨ VPN/ä»£ç† çš„å¯èƒ½æ€§ä¸ºï¼š<strong style="color:${color}">${score}%</strong>`;


    container.appendChild(table);
    container.appendChild(footer);

const oldBox = resultContainer.querySelector("div");
if (oldBox) oldBox.remove();
resultContainer.appendChild(container);
  }

  async function detectWebRTCIP() {
    if (typeof RTCPeerConnection === "undefined") return null;

    return new Promise(resolve => {
      let resolved = false;
      const candidates = new Set();
      const rtc = new RTCPeerConnection({ iceServers: CONFIG.stunServers });

      rtc.createDataChannel("dummy");
      rtc.createOffer().then(offer => rtc.setLocalDescription(offer));

      const timeout = setTimeout(() => {
        if (!resolved) {
          resolved = true;
          resolve(null);
        }
      }, CONFIG.webrtcTimeout);

      rtc.onicecandidate = event => {
        if (!event.candidate || resolved) return;
        const ipMatch = /([0-9]{1,3}(\\.[0-9]{1,3}){3})/.exec(event.candidate.candidate);
        if (ipMatch) candidates.add(ipMatch[1]);
      };

      rtc.onicegatheringstatechange = () => {
        if (rtc.iceGatheringState === "complete" && !resolved) {
          resolved = true;
          clearTimeout(timeout);
          const valid = [...candidates].filter(ip =>
            ip &&
            !ip.startsWith("192.") &&
            !ip.startsWith("10.") &&
            !ip.startsWith("172.") &&
            !ip.startsWith("127.") &&
            !ip.startsWith("0.")
          );
          resolve(valid[0] || null);
        }
      };
    });
  }

  async function detectWebRTCWrapper() {
    IPStore.webrtc = await withTimeout(detectWebRTCIP(), CONFIG.webrtcTimeout);
  }

  function compareAllIPs() {
    const { webrtc, tcp } = IPStore;
    const ipapi = IPStore.ipapiData?.ip ?? null;
    if (!webrtc || !ipapi) return { status: "ğŸŸ¢ æ­£å¸¸", color: "#00ff22" };

    const mismatch = webrtc !== ipapi || webrtc !== tcp;
    return mismatch
      ? { status: "ğŸ”´ æ£€æµ‹åˆ°å¼‚å¸¸", color: "#fb0000" }
      : { status: "ğŸŸ¢ æ­£å¸¸", color: "#00ff22" };
  }

async function fetchIPAPIData() {
  const workerList = [
    "https://uncloak1.huangjie.ggff.net",
    "https://uncloak2.huangjie.ggff.net",
    "https://uncloak3.huangjie.ggff.net",
    "https://api.ipapi.is",
    "https://uncloak3.huangjie.ggff.net"	  
  ];

  for (const url of workerList) {
    try {
      const fetchWithTimeout = new Promise((resolve, reject) => {
        const controller = new AbortController();
        const timeout = setTimeout(() => {
          controller.abort();
          reject(new Error("Timeout"));
        }, 4000);

        fetch(url, { cache: "no-store", signal: controller.signal })
          .then(res => res.json())
          .then(raw => {
            clearTimeout(timeout);
            const ip = raw?.ip ?? raw?.query ?? null;
            const location = raw.location ?? {};
            if (!ip) return reject(new Error("No IP"));

            const filtered = {
              ip,
              timezone: raw.timezone ?? location.timezone ?? "Unknown",
              country_code: raw.country_code ?? location.country_code ?? "Unknown",
              country_name: raw.country_name ?? location.country ?? "Unknown",
              region_name: raw.region_name ?? location.state ?? "",
              city: raw.city ?? location.city ?? "",
              latitude: raw.latitude ?? location.latitude ?? null,
              longitude: raw.longitude ?? location.longitude ?? null,
              continent: raw.continent ?? location.continent ?? "",
              zip: raw.zip ?? location.zip ?? "",
              is_eu_member: raw.is_eu_member ?? location.is_eu_member ?? false,
              calling_code: raw.calling_code ?? location.calling_code ?? "",
              currency_code: raw.currency_code ?? location.currency_code ?? "",
              local_time: raw.local_time ?? location.local_time ?? "",
              local_time_unix: raw.local_time_unix ?? location.local_time_unix ?? null,
              is_dst: raw.is_dst ?? location.is_dst ?? false,
              asn: raw.asn?.asn ?? raw.asn ?? null,
              org: raw.asn?.org ?? raw.org ?? "",
              is_vpn: raw.is_vpn ?? false,
              is_proxy: raw.is_proxy ?? false,
              is_tor: raw.is_tor ?? false,
              is_abuser: raw.is_abuser ?? false,
              is_crawler: raw.is_crawler ?? false,
              is_datacenter: raw.is_datacenter ?? false
            };

            IPStore.ipapiData = filtered;
            IPStore.ipapi = filtered.ip;
            resolve(filtered);
          })
          .catch(err => {
            clearTimeout(timeout);
            reject(err);
          });
      });

      const result = await fetchWithTimeout;
      if (result?.ip) return result;
    } catch (e) {
      // å¯é€‰è°ƒè¯•è¾“å‡ºï¼šconsole.warn(`æ¥å£ ${url} è¯·æ±‚å¤±è´¥`, e);
    }

    await sleep(300);
  }

  return null;
}



  // ç¬¬ä¸‰æ®µJS
  async function fetchTCPFingerprint() {
    try {
      const res = await fetch(CONFIG.tcpipAPI, { cache: "no-store" });
      const json = await res.json();
      IPStore.tcp = json.lookup_ip;
      return json.os_mismatch ?? null;
    } catch {
      return null;
    }
  }

  async function measurePingRTT(url) {
    const start = performance.now();
    try {
      const res = await fetch(url, { cache: "no-store" });
      const json = await res.json();
      IPStore.ping = json.ip;
      return performance.now() - start;
    } catch {
      return null;
    }
  }

  async function measureWebSocketRTT(url) {
    return new Promise(resolve => {
      let ws;
      let pingStart;
      let resolved = false;
      const cleanUp = value => {
        if (resolved) return;
        resolved = true;
        clearTimeout(timeout);
        try { ws?.close(); } catch {}
        resolve(value);
      };
      const timeout = setTimeout(() => cleanUp(null), CONFIG.wsTimeout);
      try {
        ws = new WebSocket(url);
      } catch {
        return cleanUp(null);
      }
      ws.onopen = () => {
        pingStart = performance.now();
        setTimeout(() => {
          try { ws.send("ping"); } catch {}
        }, 300);
      };
      ws.onmessage = () => cleanUp(performance.now() - pingStart);
      ws.onerror = () => cleanUp(null);
      ws.onclose = () => cleanUp(null);
    });
  }

async function runCDNTriangleMeasurement(visitorIP) {
  const visitorCountryCode = IPStore.ipapiData?.country_code ?? "Unknown";
  if (visitorCountryCode === "CN") {
    // é»˜è®¤è·³è¿‡å¤§é™†IPæ£€æµ‹
    return "ğŸŸ¢ æ­£å¸¸";
  }

  const endpoints = {
    "JP": "https://jp.907000.xyz",
    "KR": "https://kr.907000.xyz",
    "HK": "https://hk.sin.pp.ua",
    "TW": "https://tw.sin.pp.ua",
    "CA": "https://ca.606006.xyz",
    "DE": "https://de.606006.xyz",
    "SG": "https://sg.cdns.nyc.mn",
    "US": "https://us.cdns.nyc.mn",
    "NL": "https://nl.wed.pp.ua",
    "GB": "https://gb.wed.pp.ua",
    "ID": "https://id.toy.pp.ua",
    "IN": "https://in.toy.pp.ua",
    "AU": "https://au.oct.pp.ua",
    "BR": "https://br.oct.pp.ua",
    "AE": "https://ae.aly.pp.ua",
    "ZA": "https://za.aly.pp.ua",
    "PL": "https://pl.rwx.pp.ua",
    "TR": "https://tr.rwx.pp.ua"
  };

  const fetchTasks = Object.entries(endpoints).map(([label, url]) =>
    withTimeout(
      fetch(url)
        .then(res => res.json())
        .then(json => ({
          rtt: json.rtt ?? null,
          pop_label: json.pop_label ?? "Unknown"
        }))
        .catch(() => null),
      3000
    )
  );

  const results = await Promise.all(fetchTasks);
  const valid = results.filter(r => r && typeof r.rtt === "number");
  if (!valid.length) return "â“ æœªè¯†åˆ«";

  const best = valid.sort((a, b) => a.rtt - b.rtt)[0];
  const match = best.pop_label === visitorCountryCode;

  return match ? "ğŸŸ¢ æ­£å¸¸" : "ğŸ”´ æ£€æµ‹åˆ°å¼‚å¸¸";
}


  // ç¬¬å››æ®µJS
  function calculateSpoofScore(ipapi, delayDiff, osMismatch, geoNote, cdnMismatch, webrtcMismatch) {
    let score = 0;

    if (ipapi?.is_tor) score += 100;
    if (ipapi?.is_vpn) score += 15;
    if (ipapi?.is_proxy) score += 15;
    if (ipapi?.is_crawler) score += 5;
    if (ipapi?.is_abuser) score += 5;
    if (ipapi?.is_datacenter) score += 5;

    const browserTZ = getBrowserTimezone();
    const ipTZ = ipapi?.timezone ?? null;
    const tzMismatch = ipTZ && ipTZ !== browserTZ;
    if (tzMismatch) score += 5;

    if (delayDiff !== null && delayDiff > 90) score += 20;
    if (osMismatch === true) score += 35;
    if (geoNote === true) score += 35;
    if (cdnMismatch === true) score += 35;
    if (webrtcMismatch === true) score += 35;

    return {
      score: Math.min(score, 100),
      tzMismatch
    };
  }

  async function runAnalysisCore() {
    flashUpdate("â³ æ­£åœ¨åˆå§‹åŒ–æ£€æµ‹ï¼Œè¯·ç¨å€™â€¦");
    await sleep(500);

flashUpdate("ğŸŒ æ­£åœ¨æŸ¥è¯¢ IP ä¿¡èª‰æ•°æ®åº“â€¦");
const ipapi = await fetchIPAPIData(); // âœ… ä¸åŠ  withTimeout
if (!ipapi?.ip) {
  flashUpdate("âŒ ç½‘ç»œè¿æ¥ä¸ç¨³å®šï¼Œæ£€æµ‹è¢«ä¸­æ–­");
  return;
}
await sleep(500);


    flashUpdate("ğŸ“¦ æ­£åœ¨è¿›è¡Œ TCP/IP æŒ‡çº¹è¯†åˆ«â€¦");
    const osMismatch = await withTimeout(fetchTCPFingerprint(), 10000);
    await sleep(500);

    flashUpdate("ğŸ“¡ æ­£åœ¨è¿›è¡Œ WebRTC æ³„éœ²æ£€æµ‹â€¦");
    await detectWebRTCWrapper();
    await sleep(500);

    flashUpdate("ğŸ—ºï¸ æ­£åœ¨è¿›è¡Œé“¾è·¯å»¶è¿Ÿæµ‹é‡â€¦");
    const pingRTT = await withTimeout(measurePingRTT(CONFIG.pingURL), 6000);
    if (pingRTT === null) flashUpdate("âš ï¸ Ping æµ‹é‡å¤±è´¥ï¼Œè·³è¿‡å»¶è¿Ÿåˆ†æ");
    await sleep(500);

    const wsRTT = await withTimeout(measureWebSocketRTT(CONFIG.wsURL), 12000);
    if (wsRTT === null) flashUpdate("âš ï¸ WebSocket æµ‹é‡å¤±è´¥ï¼Œè·³è¿‡å»¶è¿Ÿåˆ†æ");
    await sleep(500);

    const countryCode = ipapi?.country_code ?? "Unknown";
    let cdnNoteRaw = "â“ æœªè¯†åˆ«";
    let delayDiff = pingRTT && wsRTT ? Math.abs(pingRTT - wsRTT) : null;
    let geoNote = "â“ æœªè¯†åˆ«";

    if (countryCode === "CN") {
      geoNote = "ğŸŸ¢ æ­£å¸¸";
      delayDiff = null;
		// é»˜è®¤è·³è¿‡å¤§é™†IPæ£€æµ‹
      cdnNoteRaw = "ğŸŸ¢ æ­£å¸¸";
    } else {
      flashUpdate("ğŸ“¡ æ­£åœ¨è¿›è¡Œ POP æœ€ä¼˜å…¥å£æ£€æµ‹â€¦");
      cdnNoteRaw = await withTimeout(runCDNTriangleMeasurement(ipapi.ip), 15000);
      await sleep(500);
    }

    const ref = GEO_BASELINE?.[countryCode]?.[CONFIG.vpsRegion];
if (countryCode !== "CN") {
  if (!ref) {
    geoNote = `â“ æœªè¯†åˆ«ï¼ˆæ—  ${countryCode} â†’ ${CONFIG.vpsRegion} æ ·æœ¬ï¼‰`;
  } else if (pingRTT == null || wsRTT == null || isNaN(pingRTT) || isNaN(wsRTT)) {
    geoNote = "â“ æœªè¯†åˆ«ï¼ˆé“¾è·¯æµ‹é‡å¤±è´¥ï¼‰";
  } else {
    const { expectedRTT, tolerance } = ref;
    const httpExceeds = pingRTT > expectedRTT + tolerance;
    const wsExceeds = wsRTT > expectedRTT + tolerance;
    geoNote = (httpExceeds || wsExceeds) ? "å¼‚å¸¸ âŒ" : "æ­£å¸¸ âœ…";
  }
}


	  

const webrtcResult = compareAllIPs();
const spoofResult = calculateSpoofScore(
  ipapi,
  delayDiff,
  osMismatch,
  geoNote === "å¼‚å¸¸ âŒ",
  cdnNoteRaw?.includes("ğŸ”´"),
  webrtcResult.status.includes("ğŸ”´")
);

console.log("è¯„åˆ†è¯¦æƒ…ï¼š", {
  is_vpn: ipapi?.is_vpn,
  is_datacenter: ipapi?.is_datacenter,
  tzMismatch: spoofResult.tzMismatch, // âœ… æ­£ç¡®å¼•ç”¨
  delayDiff,
  osMismatch,
  geoNote,
  cdnMismatch: cdnNoteRaw?.includes("ğŸ”´"),
  webrtcMismatch: webrtcResult.status.includes("ğŸ”´")
});

console.log("æœ€ç»ˆè¯„åˆ†ï¼š", spoofResult.score);

	  

    const items = [
      ["æ˜¯å¦æ ‡è®°ä¸º TOR", ipapi?.is_tor ? "ğŸ”´ å·²æ ‡è®°" : "ğŸŸ¢ æœªæ ‡è®°", ipapi?.is_tor ? "#fb0000" : "#00ff22"],
      ["æ˜¯å¦æ ‡è®°ä¸º VPN", ipapi?.is_vpn ? "ğŸ”´ å·²æ ‡è®°" : "ğŸŸ¢ æœªæ ‡è®°", ipapi?.is_vpn ? "#fb0000" : "#00ff22"],
      ["æ˜¯å¦æ ‡è®°ä¸º ä»£ç†", ipapi?.is_proxy ? "ğŸ”´ å·²æ ‡è®°" : "ğŸŸ¢ æœªæ ‡è®°", ipapi?.is_proxy ? "#fb0000" : "#00ff22"],
      ["æ˜¯å¦æ ‡è®°ä¸º çˆ¬è™«", ipapi?.is_crawler ? "ğŸ”´ å·²æ ‡è®°" : "ğŸŸ¢ æœªæ ‡è®°", ipapi?.is_crawler ? "#fb0000" : "#00ff22"],
      ["æ˜¯å¦æ ‡è®°ä¸º æ»¥ç”¨IP", ipapi?.is_abuser ? "ğŸ”´ å·²æ ‡è®°" : "ğŸŸ¢ æœªæ ‡è®°", ipapi?.is_abuser ? "#fb0000" : "#00ff22"],
      ["æ˜¯å¦æ ‡è®°ä¸º æ•°æ®ä¸­å¿ƒ", ipapi?.is_datacenter ? "ğŸ”´ å·²æ ‡è®°" : "ğŸŸ¢ æœªæ ‡è®°", ipapi?.is_datacenter ? "#fb0000" : "#00ff22"],
      ["æ—¶åŒºæ˜¯å¦ä¸€è‡´", spoofResult.tzMismatch ? "ğŸ”´ æ£€æµ‹åˆ°å¼‚å¸¸" : "ğŸŸ¢ æ­£å¸¸", spoofResult.tzMismatch ? "#fb0000" : "#00ff22"],
      ["æŒ‡çº¹çœŸå®æ€§", osMismatch === true ? "ğŸ”´ æ£€æµ‹åˆ°å¼‚å¸¸" : osMismatch === false ? "ğŸŸ¢ æ­£å¸¸" : "â“ æœªè¯†åˆ«", osMismatch === true ? "#fb0000" : "#00ff22"],
      ["é“¾è·¯å»¶è¿Ÿæµ‹é‡", delayDiff !== null && delayDiff > 90 ? "ğŸ”´ æ£€æµ‹åˆ°å¼‚å¸¸" : "ğŸŸ¢ æ­£å¸¸", delayDiff !== null && delayDiff > 90 ? "#fb0000" : "#00ff22"],
      ["åœ°ç†ä½ç½®å»¶è¿Ÿæ£€æµ‹", geoNote === "å¼‚å¸¸ âŒ" ? "ğŸ”´ æ£€æµ‹åˆ°å¼‚å¸¸" : geoNote.includes("â“") ? "â“ æœªè¯†åˆ«" : "ğŸŸ¢ æ­£å¸¸", geoNote === "å¼‚å¸¸ âŒ" ? "#fb0000" : geoNote.includes("â“") ? "#fffb00" : "#00ff22"],
      ["POP æœ€ä¼˜å…¥å£æ£€æµ‹", cdnNoteRaw ?? "â“ æœªè¯†åˆ«", cdnNoteRaw?.includes("ğŸ”´") ? "#fb0000" : "#00ff22"],
      ["WebRTC æ˜¯å¦æ³„éœ²", webrtcResult.status, webrtcResult.color]
    ];

    showResultHTML(items, spoofResult.score);
	// âœ… è‡ªåŠ¨æ¸…ç©ºæç¤ºåŒºåŸŸ
    statusText.textContent = "";
    finalResult.textContent = "";
  }

	
async function runAnalysis() {
  if (detectBtn.disabled) return;

  detectBtn.disabled = true;
  detectBtn.textContent = "æ£€æµ‹ä¸­â€¦â€¦";

  // âœ… æ¸…é™¤æ—§è¯„åˆ†ç»“æœï¼Œä½†ä¿ç•™æç¤ºåŒºåŸŸ
  const oldResultBox = resultContainer.querySelector("div");
  if (oldResultBox) oldResultBox.remove();

  // âœ… æ¸…ç©ºæç¤ºæ–‡å­—
  statusText.textContent = "";
  finalResult.textContent = "";

  loader.style.display = "block";
  await runAnalysisCore();
  loader.style.display = "none";

  detectBtn.disabled = false;
  detectBtn.textContent = "å¼€å§‹æ£€æµ‹";
}


  detectBtn.addEventListener("click", runAnalysis);
});
</script>
